<html>
    <head>
        <meta charset="utf-8" name="viewport" content="width=device-width,user-scalable=no">
		<style>
			body { margin: 0; }
			svg {
                position: absolute;
				width: 100vmin;
				height: 100vmin;
				margin: auto;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
			}
		</style>
        <script type="text/javascript" src="js/jquery-3.3.1.min.js"></script>
        <script type="text/javascript" src="js/snap.svg-min.js"></script>
        <script type="text/javascript" src="js/accessibility.js"></script>
    </head>
    <body>
        <svg viewbox='0 0 100 100'></svg>
        <script>
            function makeHex( radius ) {
                var hexVectors = [];
                for(var i=0; i<6; i+=1) {
                    hexVectors.push( 
                        innerRadius * Math.sin( i * Math.PI / 3 ), 
                        innerRadius * Math.cos( i * Math.PI / 3 )
                    );
                }
                var hex = s.polygon(hexVectors);
                return hex;
            }

            function defaultMouseover() { 
                var subScheme = this.data( this.data( 'state' ) );
                this.animate( subScheme.hover, 300, mina.easein );
            }
            function defaultMouseout() {
                var subScheme = this.data( this.data( 'state' ) );
                this.animate( subScheme.normal, 300, mina.easeout );
            }
    
            function toggleMine( ev ) {
                if( this.data( 'state' ) == 'blank' ) {
                    this.data( 'state', 'mine' )
                } else if( this.data( 'state' ) == 'mine' ) {
                    this.data( 'state', 'blank' )
                } 
                var subScheme = this.data( this.data( 'state' ) );
                this.animate( subScheme.hover, 100 );
            }
    
            function makeGrid( innerRadius, outerRadius ) {
                var tmp_hex = makeHex( innerRadius );
                var hexes = [];
                for( var h=-outerRadius; h<=outerRadius; h=h+1 ) {
                    var H = Math.abs( h );
                    for( var j=-outerRadius; j<=outerRadius; j=j+1 ) {
                        var J = Math.abs( j );
                        if( Math.abs( h + j ) > outerRadius)
                            continue;
                        var x = cx + h * _h + j * _j[ 0 ];
                        var y = cy + j * _j[ 1 ];
                        var hex = tmp_hex.clone();
                        var m = hex.transform().localMatrix;
                        m.translate( x, y );
                        hex.transform( m ); 
                        hexes.push( hex );

                        hex.data( 'state', 'blank' );
                        hex.mouseover( defaultMouseover )
                           .mouseout( defaultMouseout )
                           .mouseup( toggleMine )
                           .touchstart( defaultMouseover )
                           .touchcancel( defaultMouseout )
                           .touchend( function(){ 
                                toggleMine.call( this );
                                defaultMouseout.call( this );
                            });

                        var updateColour = function( h ) { 
                            return function( scheme ) {
                                h.data( 'blank', getSubScheme( scheme, 'blank' ) );
                                h.data( 'free', getSubScheme( scheme, 'free' ) );
                                h.data( 'mine', getSubScheme( scheme, 'mine' ) );
                                h.data( 'flag', getSubScheme( scheme, 'flag' ) );
                                var subScheme = h.data( h.data( 'state' ) );
                                h.attr( subScheme.normal );
                            }
                        }
                        eve.on( 'updateColourScheme', updateColour( hex ) );
                    }
                }
                tmp_hex.remove();
                return hexes;
            }

            function setupOptions() {
                optionsIcon.attr({
                    'width': 8,
                    'height': 8,
                    'x': 4,
                    'y': 4,
                });
                eve.on( 'updateColourScheme', function( scheme ) {
                    var subScheme = getSubScheme( scheme, 'icon' );
                    optionsIcon.data( 'subScheme', subScheme );
                    optionsIcon.select( 'path' ).attr( subScheme.normal );
                    optionsIcon.mouseover(function() {
                        this.select( 'path' ).animate( this.data( 'subScheme' ).hover, 100, mina.easein );
                    }).mouseout( function() {
                        this.select( 'path' ).animate( this.data( 'subScheme' ).normal, 100, mina.easeout );
                    });
                });
                eve( 'updateColourScheme', "self", colourScheme );
            }

            var outerRadius = 6; 
            var width = 100;
            var cx = 50;
            var cy = 50;

            var _j = [];
            var innerRadius, outerRadius, _h;
            innerRadius = 0.5 * ( width - 1 ) / ( ( 2 * outerRadius + 1 ) * Math.cos( Math.PI / 6 ) );
            _h = 2 * innerRadius * Math.cos( Math.PI / 6 );
            _j[ 0 ] = innerRadius * Math.cos( Math.PI / 6 );
            _j[ 1 ] = 2 * _j[ 0 ] * Math.cos( Math.PI / 6 );

        
            var s, hexOutlineColour, hexes, optionsIcon;
            $().ready( function() {
                s = Snap( 'svg' );
                hexes = makeGrid( innerRadius, outerRadius );
                eve( 'updateColourScheme', "self", colourScheme );
                Snap.load( 'img/cog.svg', function( data ) {
                    var q = s.add( data )
                    optionsIcon = s.select( 'svg:last-child' );
                    setupOptions();
                });
            }); 
        </script>
	</body>
</html>
